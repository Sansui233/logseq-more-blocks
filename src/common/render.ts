import MyInput from "../components/TextInput";
import { LsqTemplate, TLsqComponentIntrinsicProps, TLsqTemplate } from "../lib/component";
import { createRenderer } from "../lib/renderer";
import { dataAttrs } from "./data-attrs";
import { handlerNames } from "./handlers";


export const pluginData = createRenderer<{
  content?: string // = payloads.arguments
}>({
  name: "plugin-test"
})


export type TMyTemplate<P> = TLsqTemplate<
  P & TLsqComponentIntrinsicProps, typeof handlerNames, typeof dataAttrs
>;



type TRenderedSlottedHook = Parameters<typeof logseq.App.onMacroRendererSlotted>[0]

/**
 * render the real text into logseq slot template
 */
export const provideRendererUI: TRenderedSlottedHook = (evt) => {
  /* in logseq, {{renderer :plugin-test_dfaoj,Hi there}} will be converted to
  slot = "a slot id generated by logseq"
  payload = {
    name: "renderer",
    arguments: ["plugin-test_dfaoj", "Hi there"]
    uuid: "string-generated-by-logseq"
  }
  **/
  const { slot, payload } = evt
  // the renderer name should be like this: `:plugin-test_dfaoj`. 
  // that is pluginData.name_renderId
  // the content elements is split by comma in original text.
  const [rendererName, ...contents] = payload.arguments

  // if not the current plugin renderer, do nothing
  if (!rendererName?.startsWith(`:${pluginData.name}`)) return

  // else, render the plugin UI
  console.debug("onMacroRendererSlotted event", evt)

  const renderId = rendererName.split('_')[1]?.trim()
  if (!renderId) return


  return logseq.provideUI({
    key: pluginData.genId(renderId), // this is part of the dom id. see keepKey
    slot, // this var name should be slotid. slot means to insert into editor block. Otherwise, the plugin window will float. <div> with slot__id will wrapper outside your plugin window
    reset: true,
    template: provideUiTemplate(MyInput, {
      renderId,
      content: contents.length !== 0 ? contents.join(",") : "Hi",
      blockUuid: payload.uuid
    })
  })
}// bind handler and data types

export function provideUiTemplate<P extends TLsqComponentIntrinsicProps>(myTemplate: TMyTemplate<P>, props: P) {
  // this one will render all handlers and data attrs in a single component
  // Lsq  provide only one model for every plugin so
  // you have to dispatch behaviors for different renderer in event handler
  return LsqTemplate(myTemplate, props, handlerNames, dataAttrs);
}